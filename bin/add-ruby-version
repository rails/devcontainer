#!/usr/bin/env node

/**
 * Ruby Version Management Script
 *
 * This script automates the process of adding new Ruby versions to the devcontainer
 * configuration. It updates the GitHub workflow matrix, potentially updates the
 * default Ruby version, bumps the feature version, and updates test files.
 *
 * Usage: bin/add-ruby-version <ruby-version>
 * Example: bin/add-ruby-version 3.4.5
 *
 * The script will:
 * 1. Validate the version format
 * 2. Check if the version already exists
 * 3. Add the version to the workflow matrix
 * 4. Update the default version if the new version is newer
 * 5. Update the README.md default version
 * 6. Bump the feature version when the default changes
 * 7. Update test files to use the new version
 *
 * @author Rails Team
 * @version 1.0.0
 */

const fs = require('fs');
const semver = require('semver');

// ANSI color codes for better output
const colors = {
    reset: '\x1b[0m',
    green: '\x1b[32m',
    blue: '\x1b[34m',
    yellow: '\x1b[33m',
    red: '\x1b[31m',
    cyan: '\x1b[36m',
    magenta: '\x1b[35m'
};

// Regex patterns for version handling
const VERSION_PATTERN = '\\d+\\.\\d+\\.\\d+';
const VERSION_VALIDATION_REGEX = new RegExp(`^${VERSION_PATTERN}$`);
const VERSION_REPLACEMENT_REGEX = new RegExp(`(${VERSION_PATTERN})`, 'g');

// File paths
const VERSIONS_JSON_FILE = '.github/ruby-versions.json';
const JSON_FILE = 'features/src/ruby/devcontainer-feature.json';
const README_FILE = 'features/src/ruby/README.md';
const TEST_FILES = [
    'features/test/ruby/test.sh',
    'features/test/ruby/with_rbenv.sh'
];

// Emoji helpers
const emoji = {
    search: 'ðŸ”',
    edit: 'ðŸ“',
    check: 'âœ…',
    update: 'ðŸ”„',
    info: 'â„¹ï¸',
    party: 'ðŸŽ‰',
    file: 'ðŸ“„',
    bulb: 'ðŸ’¡',
    error: 'âŒ'
};

/**
 * Logs a message with optional color formatting
 * @param {string} message - The message to log
 * @param {string} color - The color to use (default: 'reset')
 */
function log(message, color = 'reset') {
    console.log(colors[color] + message + colors.reset);
}

/**
 * Logs an error message and exits the process
 * @param {string} message - The error message to display
 */
function exitWithError(message) {
    log(`${emoji.error} Error: ${message}`, 'red');
    process.exit(1);
}

// === FILE OPERATIONS ===
/**
 * Checks if a file exists, exits with error if not found
 * @param {string} filePath - The path to check
 */
function checkFileExists(filePath) {
    if (!fs.existsSync(filePath)) {
        log(`${emoji.error} Error: ${filePath} not found`, 'red');
        process.exit(1);
    }
}

/**
 * Reads and parses a JSON file
 * @param {string} filePath - The path to the JSON file
 * @returns {Object} The parsed JSON data
 */
function readJsonFile(filePath) {
    try {
        const content = fs.readFileSync(filePath, 'utf8');
        return JSON.parse(content);
    } catch (error) {
        throw new Error(`Could not read JSON file ${filePath}: ${error.message}`);
    }
}

/**
 * Writes data to a JSON file with formatting
 * @param {string} filePath - The path to write to
 * @param {Object} data - The data to write
 */
function writeJsonFile(filePath, data) {
    try {
        fs.writeFileSync(filePath, JSON.stringify(data, null, 4) + '\n');
    } catch (error) {
        throw new Error(`Could not write JSON file ${filePath}: ${error.message}`);
    }
}

/**
 * Updates version numbers in test files using regex replacement
 * @param {string} newVersion - The new version to replace with
 * @param {string} testFile - The test file to update
 * @returns {boolean} Success status
 */
function updateVersionInTestFile(newVersion, testFile) {
    try {
        const content = fs.readFileSync(testFile, 'utf8');
        const updatedContent = content.replace(VERSION_REPLACEMENT_REGEX, newVersion);
        fs.writeFileSync(testFile, updatedContent);
        return true;
    } catch (error) {
        throw new Error(`Could not update test file ${testFile}: ${error.message}`);
    }
}

/**
 * Updates the default version in the README.md file
 * @param {string} newVersion - The new default version
 * @param {string} readmeFile - Path to the README.md file
 * @returns {boolean} Success status
 */
function updateReadmeDefaultVersion(newVersion, readmeFile) {
    try {
        const content = fs.readFileSync(readmeFile, 'utf8');

        // Update the default value in the options table
        // Look for the pattern: | version | ... | string | X.Y.Z |
        const readmeVersionRegex = /(\| version \| [^|]+ \| string \| )(\d+\.\d+\.\d+)( \|)/;
        const updatedContent = content.replace(readmeVersionRegex, `$1${newVersion}$3`);

        fs.writeFileSync(readmeFile, updatedContent);
        return true;
    } catch (error) {
        throw new Error(`Could not update README file ${readmeFile}: ${error.message}`);
    }
}

// === VERSION VALIDATION ===
/**
 * Validates if a version string matches the expected format
 * @param {string} version - The version string to validate
 * @returns {boolean} True if valid, false otherwise
 */
function validateVersionFormat(version) {
    return VERSION_VALIDATION_REGEX.test(version);
}

/**
 * Validates that all required configuration files exist
 */
function validateConfiguration() {
    // Check if files exist
    checkFileExists(VERSIONS_JSON_FILE);
    checkFileExists(JSON_FILE);
    checkFileExists(README_FILE);

    // Check if test files exist
    for (const testFile of TEST_FILES) {
        checkFileExists(testFile);
    }
}

// === BUSINESS LOGIC ===

/**
 * Gets the current default Ruby version from the JSON configuration file
 * @param {string} jsonFile - Path to the JSON configuration file
 * @returns {string} The current default version
 */
function getCurrentDefaultVersion(jsonFile) {
    try {
        const data = readJsonFile(jsonFile);
        return data.options.version.default;
    } catch (error) {
        throw new Error(`Could not read current default version: ${error.message}`);
    }
}

/**
 * Checks if a version already exists in the versions JSON file
 * @param {string} version - The version to check for
 * @param {string} versionsFile - Path to the versions JSON file
 * @returns {boolean} True if version exists, false otherwise
 */
function versionExistsInVersionsFile(version, versionsFile) {
    try {
        const versions = readJsonFile(versionsFile);
        return versions.includes(version);
    } catch (error) {
        throw new Error(`Could not check if version exists: ${error.message}`);
    }
}

/**
 * Adds a new Ruby version to the versions JSON file and sorts the versions
 * @param {string} newVersion - The new version to add
 * @param {string} versionsFile - Path to the versions JSON file
 * @returns {boolean} Success status
 */
function addVersionToVersionsFile(newVersion, versionsFile) {
    try {
        // Read current versions
        const currentVersions = readJsonFile(versionsFile);

        // Add new version and remove duplicates
        const allVersions = [...new Set([...currentVersions, newVersion])];

        // Sort versions in descending order
        const sortedVersions = allVersions.sort((a, b) => semver.rcompare(a, b));

        // Write back to file
        writeJsonFile(versionsFile, sortedVersions);
        return true;
    } catch (error) {
        throw new Error(`Could not update versions file: ${error.message}`);
    }
}

/**
 * Updates the default Ruby version in the JSON configuration file
 * @param {string} newVersion - The new default version
 * @param {string} jsonFile - Path to the JSON configuration file
 * @returns {boolean} Success status
 */
function updateDefaultInJson(newVersion, jsonFile) {
    try {
        const data = readJsonFile(jsonFile);
        data.options.version.default = newVersion;
        writeJsonFile(jsonFile, data);
        return true;
    } catch (error) {
        throw new Error(`Could not update JSON file: ${error.message}`);
    }
}

/**
 * Increments the feature version in the JSON configuration file
 * @param {string} jsonFile - Path to the JSON configuration file
 * @returns {Object} Object containing oldVersion and newVersion
 */
function bumpFeatureVersion(jsonFile) {
    try {
        const data = readJsonFile(jsonFile);

        // Parse current version and increment patch version
        const currentVersion = data.version;
        const incrementedVersion = semver.inc(currentVersion, 'patch');

        data.version = incrementedVersion;
        writeJsonFile(jsonFile, data);

        return {
            oldVersion: currentVersion,
            newVersion: incrementedVersion
        };
    } catch (error) {
        throw new Error(`Could not bump feature version: ${error.message}`);
    }
}

/**
 * Main function that orchestrates the Ruby version addition process
 */
function main() {
    // Check command line arguments
    const args = process.argv.slice(2);

    if (args.length !== 1) {
        log('Usage: bin/add-ruby-version <ruby-version>', 'red');
        log('Example: bin/add-ruby-version 3.4.5', 'yellow');
        process.exit(1);
    }

    const newVersion = args[0];

    // Validate version format
    if (!validateVersionFormat(newVersion)) {
        exitWithError('Invalid version format. Expected format: x.y.z (e.g., 3.4.5)');
    }

    // Validate configuration
    validateConfiguration();

    try {
        // Check if version already exists
        if (versionExistsInVersionsFile(newVersion, VERSIONS_JSON_FILE)) {
            exitWithError(`Version ${newVersion} already exists in ${VERSIONS_JSON_FILE}`);
        }

        log(`${emoji.search} Checking current configuration...`, 'cyan');

        // Get current default version
        const currentDefault = getCurrentDefaultVersion(JSON_FILE);
        log(`Current default version: ${currentDefault}`);
        log(`New version to add: ${newVersion}`);

        // Add version to versions JSON file
        log('');
        log(`${emoji.edit} Adding ${newVersion} to ${VERSIONS_JSON_FILE}...`, 'blue');
        addVersionToVersionsFile(newVersion, VERSIONS_JSON_FILE);
        log(`${emoji.check} Successfully added to ${VERSIONS_JSON_FILE}`, 'green');


        // Check if new version should become the default
        const comparisonResult = semver.compare(newVersion, currentDefault);
        const filesModified = [VERSIONS_JSON_FILE];

        if (comparisonResult > 0) {
            log('');
            log(`${emoji.update} New version ${newVersion} is newer than current default ${currentDefault}`, 'yellow');
            log(`Updating default version in ${JSON_FILE}...`);
            updateDefaultInJson(newVersion, JSON_FILE);
            log(`${emoji.check} Updated default version to ${newVersion}`, 'green');

            // Update README with new default version
            log(`Updating default version in ${README_FILE}...`);
            updateReadmeDefaultVersion(newVersion, README_FILE);
            log(`${emoji.check} Updated README default version to ${newVersion}`, 'green');

            // Bump feature version when default changes
            log('');
            log(`${emoji.update} Bumping feature version...`, 'yellow');
            const versionInfo = bumpFeatureVersion(JSON_FILE);
            log(`${emoji.check} Feature version bumped from ${versionInfo.oldVersion} to ${versionInfo.newVersion}`, 'green');

            filesModified.push(JSON_FILE, README_FILE);
        } else {
            log('');
            log(`${emoji.info} New version ${newVersion} is not newer than current default ${currentDefault}`, 'cyan');
            log('Default version remains unchanged');
        }

        // Update test files only if new version is newer than current default
        log('');
        let testFilesUpdated = 0;
        if (comparisonResult > 0) {
            log(`${emoji.edit} Updating test files...`, 'blue');
            for (const testFile of TEST_FILES) {
                updateVersionInTestFile(newVersion, testFile);
                log(`${emoji.check} Updated ${testFile}`, 'green');
                filesModified.push(testFile);
                testFilesUpdated++;
            }
        } else {
            log(`${emoji.info} Skipping test file updates (new version ${newVersion} is not newer than current default ${currentDefault})`, 'cyan');
        }

        // Success message
        log('');
        log(`${emoji.party} Successfully added Ruby version ${newVersion}!`, 'green');
        log('');
        log(`${emoji.file} Files modified:`, 'blue');
        filesModified.forEach(file => {
            log(`  â€¢ ${file}`);
        });

        log('');
        log(`${emoji.bulb} Next steps:`, 'magenta');
        log(`  1. Review the changes: git diff`);
        log(`  2. Commit the changes: git add . && git commit -m 'Add Ruby ${newVersion}'`);
        log(`  3. Push changes: git push`);

    } catch (error) {
        log(`${emoji.error} Error: ${error.message}`, 'red');
        process.exit(1);
    }
}

// Run the main function
main();
